Here is a comprehensive, multi-phase plan to implement the new dashboard-centric user flow and "Account Tile" interface. This guide is written for a developer (like a Replit agent) to execute, providing clear context, goals, and code for each step, all updated to be compatible with the latest repository code you provided.

ðŸŽ¯ Mission Context for the Replit Agent
Your primary goal is to transform the application's user experience. The main entry point for logged-in users will no longer be a static page, but a dynamic "Home" dashboard that reflects the user's current state (e.g., "new user" vs. "active user with a plan").

We will then build out a new, more visual way to browse accounts using "Account Tiles," which will link to new "Account Detail" and "Plan Overview" pages. This involves significant routing changes, creating new components, and refactoring existing pages to be more modular and data-driven.

Phase 1: Aesthetic Foundation ("Subtle Glass" UI)
Goal: Before building new components, we will upgrade the app-wide aesthetic to the "Subtle Glass" theme. This ensures all new UI elements are built on the correct foundation.

1.1: Update tailwind.config.ts
File: tailwind.config.ts Action: Add the backgroundImage and boxShadow extensions inside the theme.extend object.

What this accomplishes: This defines the new radial-gradient-top for our background and the soft-lg shadows for our "glass" cards.

TypeScript

// tailwind.config.ts
// ... inside theme: { extend: { ... } }
      backgroundImage: {
        'radial-gradient-top': 'radial-gradient(40% 40% at 50% 0%, hsl(var(--primary) / 0.05), transparent 100%)',
      },
      boxShadow: {
        'soft-lg': '0px 8px 16px rgba(0, 0, 0, 0.02), 0px 16px 32px rgba(0, 0, 0, 0.08)',
        'soft-lg-dark': '0px 8px 16px rgba(0, 0, 0, 0.1), 0px 16px 32px rgba(0, 0, 0, 0.15)',
      }
// ...
1.2: Update client/src/index.css
File: client/src/index.css Action: Apply the new radial gradient to the body tag within the @layer base.

What this accomplishes: This applies the subtle gradient to the background of the entire application, giving it depth.

CSS

/* client/src/index.css */
@layer base {
  /* ... (other base styles) */
  body {
    @apply font-sans antialiased bg-background text-foreground;
    
    /* ADD THESE TWO LINES: */
    background-image: theme('backgroundImage.radial-gradient-top');
    background-repeat: no-repeat;
  }
}
1.3: Update client/src/components/ui/card.tsx
File: client/src/components/ui/card.tsx Action: Replace the existing Card component definition with this new version.

What this accomplishes: This is the core of the "Subtle Glass" look. It makes all Card components semi-transparent, adds the backdrop-blur effect, and applies our new soft-lg shadow.

TypeScript

// client/src/components/ui/card.tsx
import * as React from "react"
import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      // OLD: "shadcn-card rounded-xl border border-card-border bg-card shadow-sm"
      // NEW:
      "shadcn-card rounded-xl border border-black/5 dark:border-white/10",
      "bg-card/90 dark:bg-card/80 backdrop-blur-md",
      "shadow-soft-lg dark:shadow-soft-lg-dark",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

// ... (rest of the file: CardHeader, CardTitle, etc. remain unchanged) ...
Phase 2: Core Logic & Data Architecture
Goal: To support the new dynamic dashboard and account tiles, we must centralize our data fetching and create new, critical date-based logic.

2.1: Create Reusable Data Hooks
Action: Create a new file at client/src/hooks/use-plan-data.ts.

What this accomplishes: Currently, dashboard.tsx and accounts.tsx fetch the same data. This is inefficient. We will create reusable hooks useAccounts and useActivePlan to fetch data once and share it across components, following best practices.

TypeScript

// client/src/hooks/use-plan-data.ts
import { useQuery } from "@tanstack/react-query"
import { hc } from "hono/client"
import { type ApiRoutes } from "@server/routes"

const client = hc<ApiRoutes>("/")

// Hook to get all user accounts
export const useAccounts = () => {
  return useQuery({
    queryKey: ["accounts"],
    queryFn: async () => {
      const res = await client.api.accounts.$get()
      if (!res.ok) throw new Error("Failed to fetch accounts")
      return res.json()
    },
  })
}

// Hook to get the currently active plan
export const useActivePlan = (options: { enabled: boolean } = { enabled: true }) => {
  return useQuery({
    queryKey: ["activePlan"],
    queryFn: async () => {
      const res = await client.api.plans.active.$get()
      if (!res.ok) {
        if (res.status === 404) return null // No active plan is not an error
        throw new Error("Failed to fetch plan")
      }
      return res.json()
    },
    enabled: options.enabled, // Allows us to wait for accounts to load first
  })
}
2.2: Create "Current Date" Utility
Action: Create a new file at client/src/lib/date-utils.ts.

What this accomplishes: This is the most critical new logic for the entire feature. It provides the functions to:

getCurrentMonthIndex: Find which month of the payment plan we are currently in by comparing today's date to the plan's start date.

getDashboardStats: Use the current month index to calculate all the new dynamic stats you requested (Current Debt, Total Paid So Far, etc.).

TypeScript

// client/src/lib/date-utils.ts
import { PlanResponse, Account, PlanScheduleEntry } from "@shared/schema"

/**
 * Calculates the difference in months between two dates.
 */
function getMonthDifference(startDate: Date, endDate: Date): number {
  return (
    (endDate.getFullYear() - startDate.getFullYear()) * 12 +
    (endDate.getMonth() - startDate.getMonth())
  )
}

/**
 * Finds the index of the plan schedule that corresponds to the current date.
 * Returns -1 if the plan hasn't started, or the last index if it's finished.
 */
export function getCurrentMonthIndex(plan: PlanResponse): number {
  const planStartDate = new Date(plan.planStartDate)
  const today = new Date()

  // Set both dates to the 1st of the month for clean comparison
  planStartDate.setDate(1)
  today.setDate(1)

  if (today < planStartDate) {
    return -1 // Plan hasn't started yet
  }

  const monthIndex = getMonthDifference(planStartDate, today)

  if (monthIndex >= plan.schedule.length) {
    return plan.schedule.length - 1 // Plan is finished, return last index
  }

  return monthIndex
}

/**
 * Calculates all dynamic dashboard stats based on the current date.
 */
export function getDashboardStats(
  plan: PlanResponse,
  accounts: Account[],
  currentMonthIndex: number,
) {
  // 1. Total Debt (Current)
  const totalCurrentDebt =
    currentMonthIndex === -1
      ? // Plan hasn't started, sum initial balances
        accounts.reduce((sum, acc) => sum + acc.balanceCents, 0)
      : // Get the *starting* balance of the current month from the plan
        plan.schedule[currentMonthIndex].startingBalanceCents

  // 2. Months until next account settled (Remaining)
  const monthsRemaining = plan.accountSchedules.map(
    sched => sched.payoffTimeMonths - (currentMonthIndex + 1)
  )
  const nextAccountSettle = Math.min(...monthsRemaining.filter(m => m >= 0))

  // 3. Months until all accounts settled (Remaining)
  const allAccountsSettle = Math.max(
    0,
    plan.payoffTimeMonths - (currentMonthIndex + 1)
  )

  // 4. Next Payment
  // Find the schedule entry for the *next* month (or current if plan hasn't started)
  const nextPaymentIndex = currentMonthIndex === -1 ? 0 : currentMonthIndex + 1
  const nextPaymentEntry = plan.schedule[nextPaymentIndex]
  const nextPaymentDate = new Date(plan.planStartDate)
  nextPaymentDate.setMonth(nextPaymentDate.getMonth() + nextPaymentIndex)
  
  // Find which account gets the biggest payment next month
  let nextPaymentAccount = "Multiple"
  if (nextPaymentEntry) {
    let maxPayment = 0
    for (const [accountId, payment] of Object.entries(nextPaymentEntry.payments)) {
      if (payment > maxPayment) {
        maxPayment = payment
        const acc = accounts.find(a => a.id === accountId)
        nextPaymentAccount = acc?.name ?? "Multiple"
      }
    }
  }

  const nextPayment = {
    amount: nextPaymentEntry?.totalPaymentCents ?? 0,
    date: nextPaymentDate,
    account: nextPaymentAccount,
  }

  // 5. Total Paid So Far
  // Sum all payments from month 0 up to and *including* the current month
  const totalPaidSoFar = plan.schedule
    .slice(0, currentMonthIndex + 1) // slice(0, 0) is empty (correct for index -1)
    .reduce((sum, entry) => sum + entry.totalPaymentCents, 0)

  return {
    totalCurrentDebt,
    nextAccountSettle: isFinite(nextAccountSettle) ? nextAccountSettle : 0,
    allAccountsSettle,
    nextPayment,
    totalPaidSoFar,
  }
}
Phase 3: Global Navigation & Routing
Goal: Re-architect the app's navigation flow. We will add the global "Home" button and create the new page routes.

3.1: Update Global Sidebar
Action: Update client/src/components/ui/sidebar.tsx to add "Dashboard" (Home) as the first navigation item.

What this accomplishes: This fulfills the request for a persistent "Home" button.

TypeScript

// client/src/components/ui/sidebar.tsx
import {
  Home, // <-- ADD THIS
  CreditCard,
  CircleDollarSign,
  LineChart,
  Settings,
  LogOut,
} from "lucide-react"
// ...

const navItems = [
  {
    href: "/", // <-- NEW "HOME" LINK
    icon: Home,
    label: "Dashboard",
  },
  {
    href: "/accounts",
    icon: CreditCard,
    label: "Accounts",
  },
  // ... (rest of the items: Budget, Preferences, etc.)
]

// ... (rest of file)
3.2: Update Main Application Router
Action: Modify client/src/App.tsx to use the new "wrapper" component for the root route (/) and add the new routes.

What this accomplishes: This is the central wiring for the new user flow. It replaces the old /dashboard route with a new "wrapper" at / and adds the new detail pages /accounts/:id and /plan.

TypeScript

// client/src/App.tsx
// ... (other imports)
import { useAuth } from "@/lib/auth-context"
import { Sidebar } from "@/components/ui/sidebar"
import Accounts from "@/pages/accounts"
import Budget from "@/pages/budget"
import Preferences from "@/pages/preferences"
import Generate from "@/pages/generate"
import Onboarding from "@/pages/onboarding"
// REMOVE: import Dashboard from "@/pages/dashboard" // We are replacing this

// --- NEW PAGE IMPORTS ---
import HomePageWrapper from "@/pages/home-wrapper" // <-- NEW
import AccountDetail from "@/pages/account-detail" // <-- NEW
import PlanOverview from "@/pages/plan-overview" // <-- NEW
// ---

function App() {
  // ... (useAuth hook remains the same)

  if (isLoading) {
    // ... (your loading spinner remains the same)
  }

  return (
    <div className="flex min-h-screen">
      {session && <Sidebar />}
      <main
        className={`flex-1 p-4 md:p-8 ${
          !session ? "w-full" : "md:ml-64"
        }`}
      >
        <Switch>
          {/* ... (login and signup routes remain unchanged) ... */}

          {!session ? (
            <Redirect to="/login" />
          ) : (
            <Switch>
              <Route exact path="/">
                <HomePageWrapper /> {/* <-- CHANGED */}
              </Route>
              <Route exact path="/accounts">
                <Accounts />
              </Route>
              <Route exact path="/accounts/:id">
                <AccountDetail /> {/* <-- NEW ACCOUNT DETAIL PAGE */}
              </Route>
              <Route exact path="/budget">
                <Budget />
              </Route>
              <Route exact path="/preferences">
                <Preferences />
              </Route>
              <Route exact path="/generate">
                <Generate />
              </Route>
              <Route exact path="/onboarding">
                <Onboarding />
              </Route>
              {/* REMOVE: <Route exact path="/dashboard"><Dashboard /></Route> */}
              <Route exact path="/plan">
                <PlanOverview /> {/* <-- NEW PLAN OVERVIEW PAGE */}
              </Route>
              <Route path="*">
                <NotFound />
              </Route>
            </Switch>
          )}
        </Switch>
      </main>
    </div>
  )
}
Phase 4: The "Home" Experience (Dashboards)
Goal: Create the new HomePageWrapper and the three states it can render: "Empty," "Active," or "Redirect to Generate."

4.1: Create the home-wrapper.tsx Logic
Action: Create a new file at client/src/pages/home-wrapper.tsx.

What this accomplishes: This component is the "brain" for the / route. It uses our new data hooks to check the user's state:

State 1: No accounts? Show EmptyDashboard.

State 2: Accounts, but no plan? Redirect to /generate.

State 3: Accounts AND a plan? Show ActiveDashboard and pass the data down.

TypeScript

// client/src/pages/home-wrapper.tsx
import React from "react"
import { useAccounts, useActivePlan } from "@/hooks/use-plan-data"
import { Skeleton } from "@/components/ui/skeleton"
import EmptyDashboard from "@/pages/empty-dashboard"
import ActiveDashboard from "@/pages/active-dashboard"
import { Redirect } from "react-router-dom"

const HomePageWrapper: React.FC = () => {
  const {
    data: accounts,
    isLoading: isLoadingAccounts,
    error: accountsError,
  } = useAccounts()

  const {
    data: plan,
    isLoading: isLoadingPlan,
    error: planError,
  } = useActivePlan({
    enabled: !!accounts && accounts.length > 0, // Only fetch plan if accounts exist
  })

  // Show loading skeleton if we are fetching accounts,
  // OR if we have accounts and are now fetching the plan.
  const isLoading = isLoadingAccounts || (isLoadingPlan && !!accounts && accounts.length > 0)

  if (isLoading) {
    return (
      <div className="space-y-6">
        <Skeleton className="h-12 w-1/3" />
        <div className="grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-4">
          {[...Array(5)].map((_, i) => (
            <Skeleton key={i} className="h-28 w-full" />
          ))}
        </div>
        <Skeleton className="h-64 w-full" />
      </div>
    )
  }

  if (accountsError || planError) {
    return <div>Error loading dashboard. Please try again.</div>
  }

  // State 1: New user, no accounts
  if (!accounts || accounts.length === 0) {
    return <EmptyDashboard />
  }

  // State 2: User has accounts, but no plan
  if (accounts.length > 0 && !plan) {
    // This guides them to the next logical step
    return <Redirect to="/generate" />
  }

  // State 3: User has accounts AND a plan
  if (plan) {
    // Pass the loaded data to the active dashboard
    return <ActiveDashboard plan={plan} accounts={accounts} />
  }

  return <Skeleton className="h-screen w-full" /> // Fallback
}

export default HomePageWrapper
4.2: Create the empty-dashboard.tsx Page
Action: Create a new file at client/src/pages/empty-dashboard.tsx.

What this accomplishes: This is the "welcome" screen (Screenshot 1) for new users. It guides them to add their first account by linking to the /accounts page, which already contains your AddAccountDialog component.

TypeScript

// client/src/pages/empty-dashboard.tsx
import React from "react"
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Plus } from "lucide-react"
import { useHistory } from "react-router-dom"

const EmptyDashboard: React.FC = () => {
  const history = useHistory()

  return (
    <div className="flex items-center justify-center h-[calc(100vh-10rem)]">
      <Card className="w-full max-w-lg text-center">
        <CardHeader>
          <CardTitle className="text-2xl">Welcome to Paydown Pilot!</CardTitle>
          <CardDescription>
            You're ready to take control of your finances.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <p>
            To get started, you need to add at least one account. We'll use this
            to build your mathematically optimal paydown plan.
          </p>
          <Button
            size="lg"
            className="w-full"
            onClick={() => history.push("/accounts")} // Redirects to accounts page
          >
            <Plus className="mr-2 h-4 w-4" />
            Add Your First Account
          </Button>
        </CardContent>
      </Card>
    </div>
  )
}

export default EmptyDashboard
4.3: Create active-dashboard.tsx (from dashboard.tsx)
Action 1: Rename client/src/pages/dashboard.tsx to client/src/pages/active-dashboard.tsx. Action 2: Replace the entire contents of the newly renamed client/src/pages/active-dashboard.tsx with this code.

What this accomplishes: This refactors your existing dashboard into the new "active" state.

It no longer fetches its own data; it receives plan and accounts as props from the HomePageWrapper.

It adds the new "Accounts" and "Payment Plan" shortcut buttons in the header.

It uses our new getDashboardStats utility to render the 5 new dynamic stat cards with animations.

It re-uses your existing DebtTimeline component for the consolidated chart.

TypeScript

// client/src/pages/active-dashboard.tsx
import React from "react"
import { Link } from "react-router-dom"
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
} from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { CreditCard, GanttChartSquare } from "lucide-react"
import { formatCurrency } from "@/lib/format"
import { PlanResponse, Account } from "@shared/schema"
import { getCurrentMonthIndex, getDashboardStats } from "@/lib/date-utils"
import { DebtTimeline } from "@/components/debt-timeline"
import { motion } from "framer-motion"

// Helper for animated stats
const AnimatedStatCard: React.FC<{
  title: string
  value: string | number
  unit?: string
  description?: string
}> = ({ title, value, unit, description }) => (
  <Card>
    <CardHeader>
      <CardTitle>{title}</CardTitle>
    </CardHeader>
    <CardContent>
      <motion.div
        key={value.toString()} // Animate when value changes
        initial={{ opacity: 0, y: -10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3 }}
        className="text-3xl font-bold font-mono"
      >
        {value}
        {unit && <span className="text-2xl"> {unit}</span>}
      </motion.div>
      {description && (
        <p className="text-xs text-muted-foreground">{description}</p>
      )}
    </CardContent>
  </Card>
)

interface ActiveDashboardProps {
  plan: PlanResponse
  accounts: Account[]
}

const ActiveDashboard: React.FC<ActiveDashboardProps> = ({ plan, accounts }) => {
  const currentMonthIndex = getCurrentMonthIndex(plan)
  const stats = getDashboardStats(plan, accounts, currentMonthIndex)

  // Prep data for consolidated chart (logic from your existing dashboard)
  const chartData = {
    months: plan.schedule.map(s => s.month),
    accounts: accounts.map(account => {
      const accountSchedule = plan.accountSchedules.find(
        as => as.accountId === account.id,
      )
      return {
        name: account.name,
        data: accountSchedule?.schedule.map(s => s.endingBalanceCents / 100) ?? [],
      }
    }),
    total: plan.schedule.map(s => s.endingBalanceCents / 100),
  }

  return (
    <div className="space-y-6">
      {/* --- HEADER + SHORTCUT BUTTONS --- */}
      <div className="flex justify-between items-center">
        <h1 className="text-3xl font-bold">Dashboard</h1>
        <div className="flex space-x-2">
          <Button variant="outline" asChild>
            <Link to="/accounts">
              <CreditCard className="mr-2 h-4 w-4" />
              Accounts
            </Link>
          </Button>
          <Button variant="outline" asChild>
            <Link to="/plan">
              <GanttChartSquare className="mr-2 h-4 w-4" />
              Payment Plan
            </Link>
          </Button>
        </div>
      </div>

      {/* --- 5 NEW STAT CARDS --- */}
      <div className="grid gap-4 md:grid-cols-3 lg:grid-cols-5">
        <AnimatedStatCard
          title="Current Debt"
          value={formatCurrency(stats.totalCurrentDebt)}
        />
        <AnimatedStatCard
          title="Next Settle"
          value={stats.nextAccountSettle}
          unit="mo"
          description="Next account paid off"
        />
        <AnimatedStatCard
          title="Debt Free"
          value={stats.allAccountsSettle}
          unit="mo"
          description="All accounts paid off"
        />
        <AnimatedStatCard
          title="Next Payment"
          value={formatCurrency(stats.nextPayment.amount)}
          description={`for ${stats.nextPayment.account} in ${stats.nextPayment.date.toLocaleString(
            "default",
            { month: "long" },
          )}`}
        />
        <AnimatedStatCard
          title="Total Paid"
          value={formatCurrency(stats.totalPaidSoFar)}
          description="Since plan start"
        />
      </div>

      {/* --- MAIN CHART --- */}
      <Card>
        <CardHeader>
          <CardTitle>Consolidated Debt Timeline</CardTitle>
        </CardHeader>
        <CardContent>
          <DebtTimeline chartData={chartData} />
        </CardContent>
      </Card>
    </div>
  )
}

export default ActiveDashboard
Phase 5: The "Accounts" Flow (Tiles)
Goal: Rebuild the /accounts page to use the new tile component.

5.1: Create the AccountTile Component
Action: Create a new file at client/src/components/account-tile.tsx.

What this accomplishes: This is the new "Account Tile" component. It includes:

An SVG-based circular progress bar.

The progress logic, which uses currentMonthIndex to calculate the percentage of months passed.

The dynamic stats (Current Balance, Next Payment) also derived from the currentMonthIndex.

A <Link> wrapper that makes the entire tile clickable, navigating to the new /accounts/:id detail page.

TypeScript

// client/src/components/account-tile.tsx
import React from "react"
import { Link } from "react-router-dom"
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card"
import { formatCurrency, formatPercentage } from "@/lib/format"
import { Account, AccountPlanSchedule } from "@shared/schema"

interface AccountTileProps {
  account: Account
  schedule: AccountPlanSchedule
  currentMonthIndex: number
}

const AccountTile: React.FC<AccountTileProps> = ({
  account,
  schedule,
  currentMonthIndex,
}) => {
  // --- Progress Logic ---
  const totalMonths = schedule.payoffTimeMonths
  const monthsPassed = currentMonthIndex + 1
  // Calculate progress, ensuring it's between 0 and 100
  const progress =
    totalMonths > 0
      ? Math.max(0, Math.min(100, (monthsPassed / totalMonths) * 100))
      : 0

  // --- Stat Logic ---
  const currentData = schedule.schedule[currentMonthIndex]
  const nextData = schedule.schedule[currentMonthIndex + 1]

  const currentBalance =
    currentMonthIndex === -1
      ? account.balanceCents // Plan hasn't started
      : currentData?.startingBalanceCents ?? 0
  const nextPayment = nextData?.paymentCents ?? 0

  // --- SVG Circle Logic ---
  const radius = 40
  const circumference = 2 * Math.PI * radius
  const strokeDashoffset = circumference - (progress / 100) * circumference

  return (
    <Card
      asChild
      className="flex flex-col justify-between transition-all duration-200 hover:shadow-primary/20 hover:-translate-y-1"
    >
      <Link to={`/accounts/${account.id}`}>
        <CardHeader className="items-center text-center">
          <div className="relative w-28 h-28">
            <svg className="w-full h-full" viewBox="0 0 100 100">
              <circle // Background
                cx="50" cy="50" r={radius}
                className="stroke-muted/50"
                strokeWidth="10" fill="transparent"
              />
              <circle // Progress
                cx="50" cy="50" r={radius}
                className="stroke-primary"
                strokeWidth="10" fill="transparent"
                strokeDasharray={circumference}
                strokeDashoffset={strokeDashoffset}
                strokeLinecap="round"
                transform="rotate(-90 50 50)"
              />
            </svg>
            <div className="absolute inset-0 flex flex-col items-center justify-center p-4">
              <CardTitle className="text-lg leading-tight">
                {account.name}
              </CardTitle>
              <CardDescription>{account.type}</CardDescription>
            </div>
          </div>
        </CardHeader>
        <CardFooter className="flex-col items-start border-t pt-4">
          <StatRow label="Current Bal." value={formatCurrency(currentBalance)} />
          <StatRow label="Next Payment" value={formatCurrency(nextPayment)} />
          <StatRow label="APR" value={formatPercentage(account.apr)} />
          <StatRow label="Original Bal." value={formatCurrency(account.balanceCents)} />
        </CardFooter>
      </Link>
    </Card>
  )
}

// Helper component for clean rows
const StatRow: React.FC<{ label: string; value: string }> = ({
  label,
  value,
}) => (
  <div className="flex justify-between w-full text-sm">
    <span className="text-muted-foreground">{label}</span>
    <span className="font-medium font-mono">{value}</span>
  </div>
)

export default AccountTile
5.2: Refactor the accounts.tsx Page
Action: Replace the entire content of client/src/pages/accounts.tsx with this code.

What this accomplishes: This rebuilds the /accounts page.

It now uses our useAccounts and useActivePlan hooks.

It keeps your existing AddAccountDialog component and its trigger button.

It renders an Alert if the user has accounts but no plan, guiding them to /generate.

It renders a grid of the new AccountTile components instead of the old list.

TypeScript

// client/src/pages/accounts.tsx
import React from "react"
import { useAccounts, useActivePlan } from "@/hooks/use-plan-data"
import { Skeleton } from "@/components/ui/skeleton"
import AccountTile from "@/components/account-tile"
import { Plus, Terminal } from "lucide-react"
import { Button } from "@/components/ui/button"
import { getCurrentMonthIndex } from "@/lib/date-utils"
import { AddAccountDialog } from "@/components/add-account-dialog"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Link } from "react-router-dom"

const AccountsPage: React.FC = () => {
  const [isAddAccountOpen, setIsAddAccountOpen] = React.useState(false)
  
  const { data: accounts, isLoading: isLoadingAccounts } = useAccounts()
  const { data: plan, isLoading: isLoadingPlan } = useActivePlan({
    enabled: !!accounts && accounts.length > 0,
  })

  const isLoading = isLoadingAccounts || (isLoadingPlan && !!accounts && accounts.length > 0)

  // Show a skeleton grid while loading
  if (isLoading) {
    return (
      <div className="space-y-6">
         <Skeleton className="h-12 w-1/3" />
         <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          <Skeleton className="h-64 w-full" />
          <Skeleton className="h-64 w-full" />
          <Skeleton className="h-64 w-full" />
        </div>
      </div>
    )
  }

  const currentMonthIndex = plan ? getCurrentMonthIndex(plan) : -1

  return (
    <AddAccountDialog open={isAddAccountOpen} onOpenChange={setIsAddAccountOpen}>
      <div className="space-y-6">
        <div className="flex justify-between items-center">
          <h1 className="text-3xl font-bold">Your Accounts</h1>
          <Button onClick={() => setIsAddAccountOpen(true)}>
            <Plus className="mr-2 h-4 w-4" />
            Add Account
          </Button>
        </div>

        {/* State: Has accounts, but no plan */}
        {!plan && accounts && accounts.length > 0 && (
          <Alert>
            <Terminal className="h-4 w-4" />
            <AlertTitle>Plan Required</AlertTitle>
            <AlertDescription>
              You've added accounts, but you need to generate a payment plan to
              see your progress.
              <Button asChild variant="link" className="p-0 pl-1 h-auto">
                <Link to="/generate">Generate Your Plan</Link>
              </Button>
            </AlertDescription>
          </Alert>
        )}

        {/* State: Has accounts AND a plan */}
        {plan && accounts && (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
            {accounts.map(account => {
              const schedule = plan.accountSchedules.find(
                s => s.accountId === account.id
              )
              if (!schedule) return null // Account not in plan

              return (
                <AccountTile
                  key={account.id}
                  account={account}
                  schedule={schedule}
                  currentMonthIndex={currentMonthIndex}
                />
              )
            })}
          </div>
        )}

        {/* State: No accounts */}
        {(!accounts || accounts.length === 0) && (
           <div className="text-center text-muted-foreground pt-12">
             <p>You haven't added any accounts yet.</p>
             <Button 
                variant="link" 
                onClick={() => setIsAddAccountOpen(true)}
              >
                Add your first account to get started.
             </Button>
           </div>
        )}
      </div>
    </AddAccountDialog>
  )
}

export default AccountsPage
Phase 6: The "Plan & Detail" Flow (New Pages)
Goal: Create the new drill-down pages for /plan and /accounts/:id. This requires making a reusable table component first.

6.1: Create Reusable PaymentScheduleTable Component
Action: Create a new file at client/src/components/payment-schedule-table.tsx. Copy the table logic from client/src/pages/generate.tsx into this new file.

What this accomplishes: Your generate.tsx page already has a perfect payment schedule table. We are extracting this into a reusable component so we can use it on both the new "Account Detail" page and the "Plan Overview" page.

TypeScript

// client/src/components/payment-schedule-table.tsx
import React from "react"
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { formatCurrency } from "@/lib/format"
import { PlanScheduleEntry } from "@shared/schema"

interface PaymentScheduleTableProps {
  // Can accept either a consolidated or single-account schedule
  schedule: PlanScheduleEntry[]
}

export const PaymentScheduleTable: React.FC<PaymentScheduleTableProps> = ({
  schedule,
}) => {
  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead className="w-[100px]">Month</TableHead>
          <TableHead>Start Balance</TableHead>
          <TableHead>Payment</TableHead>
          <TableHead>Interest</TableHead>
          <TableHead>End Balance</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {schedule.map(entry => (
          <TableRow key={entry.month}>
            <TableCell>{entry.month}</TableCell>
            <TableCell>{formatCurrency(entry.startingBalanceCents)}</TableCell>
            <TableCell>{formatCurrency(entry.totalPaymentCents)}</TableCell>
            <TableCell className="text-red-500/80">
              {formatCurrency(entry.totalInterestCents)}
            </TableCell>
            <TableCell>{formatCurrency(entry.endingBalanceCents)}</TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  )
}
6.2: Create the account-detail.tsx Page
Action: Create a new file at client/src/pages/account-detail.tsx.

What this accomplishes: This is the new page for the /accounts/:id route (Screenshot 2 & 3).

It uses useParams to get the account ID from the URL.

It finds the specific account and its schedule from our data hooks.

It renders your existing AccountTimeline component (from client/src/components/account-timeline.tsx).

It renders our new reusable PaymentScheduleTable component.

TypeScript

// client/src/pages/account-detail.tsx
import React from "react"
import { useParams, Link } from "react-router-dom"
import { useAccounts, useActivePlan } from "@/hooks/use-plan-data"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
} from "@/components/ui/card"
import { AccountTimeline } from "@/components/account-timeline"
import { PaymentScheduleTable } from "@/components/payment-schedule-table"
import { getCurrentMonthIndex } from "@/lib/date-utils"
import { ArrowLeft } from "lucide-react"
import { Button } from "@/components/ui/button"

const AccountDetail: React.FC = () => {
  const { id } = useParams<{ id: string }>()
  const { data: accounts, isLoading: isLoadingAccounts } = useAccounts()
  const { data: plan, isLoading: isLoadingPlan } = useActivePlan({
    enabled: !!accounts,
  })

  const isLoading = isLoadingAccounts || isLoadingPlan

  if (isLoading) {
    return (
      <div className="space-y-4">
        <Skeleton className="h-8 w-48" />
        <Skeleton className="h-12 w-1/3" />
        <Skeleton className="h-64 w-full" />
        <Skeleton className="h-64 w-full" />
      </div>
    )
  }

  if (!plan || !accounts) return <div>Plan not found.</div>

  const account = accounts.find(a => a.id === id)
  const accountSchedule = plan.accountSchedules.find(s => s.accountId === id)
  const currentMonthIndex = getCurrentMonthIndex(plan)

  if (!accountSchedule || !account) {
    return <div>Account not found in plan.</div>
  }

  return (
    <div className="space-y-6">
      <Button variant="outline" asChild>
        <Link to="/accounts">
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to All Accounts
        </Link>
      </Button>

      <h1 className="text-3xl font-bold">{account.name} - Breakdown</h1>

      <Card>
        <CardHeader>
          <CardTitle>Payment Timeline</CardTitle>
        </CardHeader>
        <CardContent>
          {/* This component will be updated in Phase 7 to add the highlight */}
          <AccountTimeline
            schedule={accountSchedule.schedule}
            currentMonthIndex={currentMonthIndex} 
          />
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Payment Schedule</CardTitle>
        </CardHeader>
        <CardContent>
          <PaymentScheduleTable schedule={accountSchedule.schedule} />
        </CardContent>
      </Card>
    </div>
  )
}

export default AccountDetail
6.3: Create the plan-overview.tsx Page
Action: Create a new file at client/src/pages/plan-overview.tsx.

What this accomplishes: This is the destination for the "Payment Plan" shortcut button. It's a clean page that shows the consolidated plan, just like your generate.tsx page.

It renders your existing DebtTimeline (ECharts) component.

It renders our new reusable PaymentScheduleTable component, passing it the main plan schedule.

TypeScript

// client/src/pages/plan-overview.tsx
import React from "react"
import { useActivePlan, useAccounts } from "@/hooks/use-plan-data"
import { Skeleton } from "@/components/ui/skeleton"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { DebtTimeline } from "@/components/debt-timeline"
import { PaymentScheduleTable } from "@/components/payment-schedule-table"
import { Link } from "react-router-dom"
import { Button } from "@/components/ui/button"
import { ArrowLeft } from "lucide-react"

const PlanOverview: React.FC = () => {
  const { data: plan, isLoading: isLoadingPlan } = useActivePlan({ enabled: true })
  const { data: accounts, isLoading: isLoadingAccounts } = useAccounts()
  
  const isLoading = isLoadingPlan || isLoadingAccounts

  if (isLoading) {
    return (
      <div className="space-y-4">
        <Skeleton className="h-8 w-48" />
        <Skeleton className="h-12 w-1/3" />
        <Skeleton className="h-64 w-full" />
        <Skeleton className="h-64 w-full" />
      </div>
    )
  }

  if (!plan || !accounts) return <div>Plan not found.</div>

  // --- Prep data for charts (same as your active-dashboard) ---
  const chartData = {
    months: plan.schedule.map(s => s.month),
    accounts: accounts.map(account => {
      const accountSchedule = plan.accountSchedules.find(
        as => as.accountId === account.id,
      )
      return {
        name: account.name,
        data: accountSchedule?.schedule.map(s => s.endingBalanceCents / 100) ?? [],
      }
    }),
    total: plan.schedule.map(s => s.endingBalanceCents / 100),
  }

  return (
    <div className="space-y-6">
      <Button variant="outline" asChild>
        <Link to="/">
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Dashboard
        </Link>
      </Button>

      <h1 className="text-3xl font-bold">Consolidated Payment Plan</h1>

      <Card>
        <CardHeader>
          <CardTitle>Consolidated Debt Timeline</CardTitle>
        </CardHeader>
        <CardContent>
          <DebtTimeline chartData={chartData} />
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Full Payment Schedule</CardTitle>
        </CardHeader>
        <CardContent>
          <PaymentScheduleTable schedule={plan.schedule} />
        </CardContent>
      </Card>
    </div>
  )
}

export default PlanOverview
Phase 7: Final Polish (Chart Highlight)
Goal: Fulfill the request to highlight the "current month" on the individual account timeline (Screenshot 2).

7.1: Upgrade account-timeline.tsx
Action: Replace the content of client/src/components/account-timeline.tsx with this new version.

What this accomplishes:

It adds currentMonthIndex to the component's props.

It defines a new HighlightedDot sub-component.

This new dot component checks if its data payload.month matches the currentMonthIndex.

If it matches, it renders a larger, styled dot. If not, it renders null (no dot).

This is applied to the <Line ... /> component using its dot prop.

TypeScript

// client/src/components/account-timeline.tsx
import { formatCurrency } from "@/lib/format"
import {
  CartesianGrid,
  Line,
  LineChart,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
} from "recharts"

// --- 1. DEFINE A CUSTOM DOT COMPONENT ---
const HighlightedDot = (props: any) => {
  const { cx, cy, stroke, payload, currentMonthIndex } = props

  // Check if the dot's month (payload.month) matches the current month (index + 1)
  if (payload.month === currentMonthIndex + 1) { 
    return (
      <svg x={cx - 8} y={cy - 8} width={16} height={16} fill="white" >
        {/* Outer pulse */}
        <circle cx="8" cy="8" r="8" fill={stroke} opacity={0.3} />
        {/* Inner dot */}
        <circle cx="8" cy="8" r="5" stroke="white" strokeWidth="2" fill={stroke} />
      </svg>
    )
  }

  return null // Render no dot for other points
}

// --- 2. DEFINE CUSTOM TOOLTIP (from your existing file) ---
const CustomTooltip = ({ active, payload, label }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="rounded-lg border bg-background p-2 shadow-sm">
        <div className="grid grid-cols-1 gap-2">
          <div className="flex flex-col">
            <span className="text-[0.70rem] uppercase text-muted-foreground">
              Month {label}
            </span>
            <span className="font-bold text-foreground">
              {formatCurrency(payload[0].value * 100)}
            </span>
          </div>
        </div>
      </div>
    )
  }
  return null
}

// --- 3. UPDATE THE COMPONENT PROPS AND RENDER ---
interface AccountTimelineProps {
  schedule: {
    month: number
    startingBalanceCents: number
    paymentCents: number
    interestCents: number
    endingBalanceCents: number
  }[]
  currentMonthIndex: number // <-- ADD THIS PROP
}

export const AccountTimeline: React.FC<AccountTimelineProps> = ({
  schedule,
  currentMonthIndex, // <-- DESTRUCTURE THE PROP
}) => {
  const formattedData = schedule.map(entry => ({
    month: entry.month,
    balance: entry.endingBalanceCents / 100,
  }))

  return (
    <ResponsiveContainer width="100%" height={300}>
      <LineChart
        data={formattedData}
        margin={{
          top: 5,
          right: 10,
          left: 10,
          bottom: 0,
        }}
      >
        <CartesianGrid strokeDasharray="3 3" vertical={false} />
        <XAxis
          dataKey="month"
          stroke="hsl(var(--muted-foreground))"
          fontSize={12}
        />
        <YAxis
          stroke="hsl(var(--muted-foreground))"
          fontSize={12}
          tickFormatter={value => formatCurrency(value * 100)}
        />
        <Tooltip content={<CustomTooltip />} />
        <Line
          type="monotone"
          dataKey="balance"
          stroke="hsl(var(--primary))"
          strokeWidth={2}
          // --- 4. ADD THE CUSTOM DOT RENDERER ---
          dot={<HighlightedDot currentMonthIndex={currentMonthIndex} />}
          activeDot={{ r: 6 }}
        />
      </LineChart>
    </ResponsiveContainer>
  )
}